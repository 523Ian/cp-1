#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;
#define pb push_back
#define INF 1000000000
vi dist(10001, INF);
vi parent(10001, 0);
vector<vii> G;

class ConnectingGameDiv2 {
  map<char, int> W;

  void dijkstra(int n) {
    dist[n] = 0;
    priority_queue<ii, vector<ii>, greater<ii> > pq;
    pq.push(ii(0, n));

    while(!pq.empty()) {
      ii front = pq.top();
      pq.pop();
      int u = front.second, d = front.first;

      if(d > dist[u])
	continue;

      for(int i=0; i<G[u].size(); i++) {
	ii v = G[u][i];
	if(dist[u] + v.second < dist[v.first]) {
	  dist[v.first] = dist[u] + v.second;
	  parent[v.first] = u;
	  pq.push(ii(dist[v.first], v.first));
	}
      }
    }
  }

public:
  int getmin(vector <string> M) {
    set<char> S;
    for(int i=0; i<M.size(); i++)
      for(int j=0; j<M[0].length(); j++) {
	if(W.count(M[i][j]) == 0) W[M[i][j]] = 1;
	else W[M[i][j]]++;
	S.insert(M[i][j]);
      }

    int X[8] = {1, 1, 0, -1, -1, -1, 0, 1};
    int Y[8] = {0, 1, 1, 1, 0, -1, -1, -1};

    set<char> VS[255];
    for(int i=0; i<M.size(); i++)
      for(int j=0; j<M[0].length(); j++) {
	for(int k=0; k<8; k++) {
	  int a = i + Y[k];
	  int b = j + X[k];
	  if(a >= 0 && b >= 0 && a < M.size() && b < M[0].length())
	    VS[M[i][j]].insert(M[a][b]);
	}
      }

    G.assign(255, vii());

    for(set<char>::iterator it=S.begin(); it!=S.end(); it++) {
      for(set<char>::iterator it2=VS[(*it)].begin(); it2!=VS[(*it)].end(); it2++) {
	if((*it) != (*it2)) {
	  G[(*it)].push_back(ii((*it2), W[(*it2)]));
	}
      }
    }

    set<char> lol, lol2;
    for(int i=0; i<M.size(); i++) {
      lol.insert(M[i][0]);
      lol2.insert(M[i][M[0].length()-1]);
    }
    for(set<char>::iterator it=lol.begin(); it!=lol.end(); it++)
      G[0].push_back(ii((*it), W[(*it)]));
    for(set<char>::iterator it=lol2.begin(); it!=lol2.end(); it++)
      G[(*it)].push_back(ii(1, 0));

    dist.assign(10001, INF);
    dijkstra(0);

    return dist[1];
  }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	ConnectingGameDiv2 *obj;
	int answer;
	obj = new ConnectingGameDiv2();
	clock_t startTime = clock();
	answer = obj->getmin(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"AA","BC"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"AAB","ACD","CCD"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"iii","iwi","iii"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 8;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"rng58","Snuke","Sothe"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"yyAArJqjWTH5","yyEEruYYWTHG","hooEvutpkkb2","OooNgFFF9sbi","RRMNgFL99Vmm","R76XgFF9dVVV","SKnZUPf88Vee"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 14;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"AAAAAAaaabcdefg","AAAAAAhhDDDDDDD","AAAAiAjDDDDDDDD","AAAAiijDDDDDDDD","AAAAAAAkDDDDDDD","AAAAoAAAlDDDDDD","AAApBnAAlDDDDDD","srqBBBmmmmDDDDD"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 26;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
